<pre><code>Date:   2014年6月18日 下午8:26
Location:   中国广东省深圳市南山区南头街道南头泉园路39号, 深圳市, 广东省, 中国
Weather:    30° Mostly Clear
</code></pre>

<h1>iPhone与Mac的USB通信</h1>

<p>最近想通过USB数据线给APP发数据和取数据的研究，想着官方的iTunes就是使用USB连接iPhone的，所以就查了些iTunes相关的资料，才发现原来还有个<code>usbmux</code>进程的存在。既然是这样那我们就动用神器<code>socat</code>来抓个包分析一下iTunes是如何跟iPhone连接通信的。 </p>

<h4>1、socat</h4>

<p>下载：传送门 — 选个最新的版本就行
编译：打开终端进入解压的目录分别执行下面命令</p>

<blockquote><p>1）./configure
2）make
3）sudo make install</p></blockquote>

<p>安装完成之后会在/usr/local/bin下生成socat的执行文件。</p>

<h4>2、抓包</h4>

<p>在终端执行以下命令之后再打开iTunes：</p>

<blockquote><p>sudo mv /var/run/usbmuxd /var/run/usbmuxx
sudo socat -t100 -x -v UNIX-LISTEN:/var/run/usbmuxd,mode=777,reuseaddr,fork UNIX-CONNECT:/var/run/usbmuxx</p></blockquote>

<p><img src="https://github.com/iKyle/ikyle.github.com/blob/gh-pages/blog/2014/06/18/iphoneyu-macde-usbtong-xin/pic/iTunes%E8%BF%9E%E6%8E%A5%E6%8A%93%E5%8C%85.gif" alt="iTunes连接抓包" title="iTunes连接抓包" width="200"/ ></p>

<h4>3、分析</h4>

<p>通过抓到的包查看数据可以发现数据是一个xml格式的数据，内容是kv的方式保存，而数据最前的16位应该就是包头啦。
我们来细看一下第一个包的内容，如下截图：</p>

<p><img src="/images/2014/06/18/Listen.png" alt="" />
<img src="https://github.com/iKyle/ikyle.github.com/blob/gh-pages/blog/2014/06/18/iphoneyu-macde-usbtong-xin/pic/Listen.png" alt="Listen.png" title="Listen" width="200"/ ></p>

<p>发现有一个比较特别的<code>key</code>叫做<code>MessageType</code>，而<code>value</code>是一个字符串<code>Listen</code>。同时我们再看看第二个包的内容，如下截图：</p>

<p><img src="/Users/wukyle/Desktop/pic/DeviceID.png" alt="DeviceID.png" title="DeviceID" width="200"/ ></p>

<p>也同时存在这个<code>MessageType</code>的<code>key</code>，但它的<code>value</code>变成了字符串<code>Attached</code>，而且这个包还多了一个比较起眼的<code>DeviceID</code>的<code>key</code>，这个应该是USB接口的ID序列号啦。</p>

<p>拿到了USB相关的信息，应该是能连接这个USB了吧，所以我们再往下看第三个包的内容，如下截图：</p>

<p><img src="/Users/wukyle/Desktop/pic/connect.png" alt="connect.png" title="connect" width="200"/ ></p>

<p>可以看到<code>key</code>为<code>MessageType</code>的值变成了<code>Connect</code>，而<code>key</code>为<code>DeviceID</code>的值也带上了，并且这时又多了一个<code>ProNumber</code>的<code>key</code>，看字面意义应该是端口号的意义。</p>

<p>那么大概可以总结出一个这样的时序图：</p>

<p><img src="/Users/wukyle/Desktop/pic/时序图.png" alt="时序图.png" title="时序图" width="200"/ ></p>

<p>4、协议
了解完大概的整个流程之后，我们要是想写一个使用USB线来通信的APP，那么就还得要再弄懂传输的协议是什么内容。</p>

<p>传送门：<a href="http://theiphonewiki.com/wiki/Usbmux" title="usbmux">http://theiphonewiki.com/wiki/Usbmux</a>
我觉得这份资料只能做为参与，因为里面提到的协议结构有一部分我一直是调试不出来，所以我们就只先看一下<code>usbmux_header</code>这个结构。</p>

<pre><code>struct usbmux_header {
    u32 length;     // length of message, including header
    u32 reserved;   // always zero
    u32 type;           // message type
    u32 tag;            // responses to this query will echo back this tag
};
</code></pre>

<p>来对比一下第一个Listen的数据包内容，如下：</p>

<p><img src="/Users/wukyle/Desktop/pic/pasted.png" alt="pasted.png" title=“数据头” width="200"/ ></p>

<p>包头的数据应该是对应的，而之后紧跟的应该就是数据包的真实内容啦，这里一眼就能看出是一个xml的数据包。
所以整个包体的协议应该是这样的：</p>

<pre><code>typedef struct usbmux_packet {
        struct usbmux_header   header;
        char data[0];
} usbmux_packet_t;
</code></pre>

<p>而xml的数据长度可以从<code>usbmux_header</code>中获取得到（length），然后再转成自己想要的类型，如字典类型<code>NSDictionary</code>、等。</p>

<p> <strong>PS：</strong>Client在使用<code>socket</code>连接<code>usbmuxd</code>之后返回了device ID，这时再第二次带上device ID连接<code>usbmuxd</code>时这里的socket就要重新创建一个新的<code>socket</code>，不能再复用之前第一次连接<code>socket</code>，否则会一直连接上不。</p>
