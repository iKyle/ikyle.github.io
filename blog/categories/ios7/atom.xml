<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS7 | kyle's blog]]></title>
  <link href="http://www.cnkyle.com/blog/categories/ios7/atom.xml" rel="self"/>
  <link href="http://www.cnkyle.com/"/>
  <updated>2014-06-26T17:02:44+08:00</updated>
  <id>http://www.cnkyle.com/</id>
  <author>
    <name><![CDATA[kylewu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iPhone与Mac的USB通信]]></title>
    <link href="http://www.cnkyle.com/blog/2014/06/18/iphoneyu-macde-usbtong-xin/"/>
    <updated>2014-06-18T20:00:00+08:00</updated>
    <id>http://www.cnkyle.com/blog/2014/06/18/iphoneyu-macde-usbtong-xin</id>
    <content type="html"><![CDATA[<!--more-->


<p>最近想通过USB数据线给APP发数据和取数据的研究，想着官方的iTunes就是使用USB连接iPhone的，所以就查了些iTunes相关的资料，才发现原来还有个<code>usbmux</code>进程的存在。既然是这样那我们就动用神器 <code>socat</code> 来抓个包分析一下iTunes是如何跟iPhone连接通信的。 </p>

<h1>1、socat</h1>

<p>下载：传送门 — 选个最新的版本就行
编译：打开终端进入解压的目录分别执行下面命令</p>

<pre><code>1）./configure
2）make
3）sudo make install
</code></pre>

<p>安装完成之后会在/usr/local/bin下生成socat的执行文件。</p>

<h1>2、抓包</h1>

<p>在终端执行以下命令之后再打开iTunes：</p>

<pre><code>sudo mv /var/run/usbmuxd /var/run/usbmuxx
sudo socat -t100 -x -v UNIX-LISTEN:/var/run/usbmuxd,mode=777,reuseaddr,fork UNIX-CONNECT:/var/run/usbmuxx
</code></pre>

<p><img src="http://www.cnkyle.com/images/2014/06/18/iTunes%E8%BF%9E%E6%8E%A5%E6%8A%93%E5%8C%85.gif" alt="iTunes连接抓包" title="iTunes连接抓包" width=“400"/ ></p>

<h1>3、分析</h1>

<p>通过抓到的包查看数据可以发现数据是一个xml格式的数据，内容是kv的方式保存，而数据最前的16位应该就是包头啦。
我们来细看一下第一个包的内容，如下截图：</p>

<p><img src="http://www.cnkyle.com/images/2014/06/18/Listen.png" alt=“图1” title="Listen" width=“400"/ ></p>

<p>发现有一个比较特别的<code>key</code>叫做<code>MessageType</code>，而<code>value</code>是一个字符串<code>Listen</code>。同时我们再看看第二个包的内容，如下截图：</p>

<p><img src="http://www.cnkyle.com/images/2014/06/18/DeviceID.png" alt="DeviceID.png" title="DeviceID" width=“400"/ ></p>

<p>也同时存在这个<code>MessageType</code>的<code>key</code>，但它的<code>value</code>变成了字符串<code>Attached</code>，而且这个包还多了一个比较起眼的<code>DeviceID</code>的<code>key</code>，这个应该是USB接口的ID序列号啦。</p>

<p>拿到了USB相关的信息，应该是能连接这个USB了吧，所以我们再往下看第三个包的内容，如下截图：</p>

<p><img src="http://www.cnkyle.com/images/2014/06/18/connect.png" alt="connect.png" title="connect" width=“400"/ ></p>

<p>可以看到<code>key</code>为<code>MessageType</code>的值变成了<code>Connect</code>，而<code>key</code>为<code>DeviceID</code>的值也带上了，并且这时又多了一个<code>ProNumber</code>的<code>key</code>，看字面意义应该是端口号的意义。</p>

<p>那么大概可以总结出一个这样的时序图：</p>

<p><img src="http://www.cnkyle.com/images/2014/06/18/时序图.png" alt="时序图.png" title="时序图" width=“400"/ ></p>

<h1>4、协议</h1>

<p>了解完大概的整个流程之后，我们要是想写一个使用USB线来通信的APP，那么就还得要再弄懂传输的协议是什么内容。</p>

<p>传送门：<a href="http://theiphonewiki.com/wiki/Usbmux" title="usbmux">http://theiphonewiki.com/wiki/Usbmux</a>
我觉得这份资料只能做为参与，因为里面提到的协议结构有一部分我一直是调试不出来，所以我们就只先看一下<code>usbmux_header</code>这个结构。</p>

<p>```objc
struct usbmux_header {</p>

<pre><code>u32 length;     // length of message, including header
u32 reserved;   // always zero
u32 type;           // message type
u32 tag;            // responses to this query will echo back this tag
</code></pre>

<p>};
```</p>

<p>来对比一下第一个Listen的数据包内容，如下：</p>

<p><img src="http://www.cnkyle.com/images/2014/06/18/pasted.png" alt="pasted.png" title=“数据头” width=“400"/ ></p>

<p>包头的数据应该是对应的，而之后紧跟的应该就是数据包的真实内容啦，这里一眼就能看出是一个xml的数据包。
所以整个包体的协议应该是这样的：</p>

<p>```objc
typedef struct usbmux_packet {</p>

<pre><code>    struct usbmux_header   header;
    char data[0];
</code></pre>

<p>} usbmux_packet_t;
```</p>

<p>而xml的数据长度可以从<code>usbmux_header</code>中获取得到（length），然后再转成自己想要的类型，如字典类型<code>NSDictionary</code>、等。</p>

<p> <strong>PS：</strong>Client在使用<code>socket</code>连接<code>usbmuxd</code>之后返回了device ID，这时再第二次带上device ID连接<code>usbmuxd</code>时这里的socket就要重新创建一个新的<code>socket</code>，不能再复用之前第一次连接<code>socket</code>，否则会一直连接上不。</p>
]]></content>
  </entry>
  
</feed>
